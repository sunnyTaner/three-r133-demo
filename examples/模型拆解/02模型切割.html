<!DOCTYPE html>
<html lang="en">
<head>
	<title>模型切割</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta charset="utf-8">
	<link type="text/css" rel="stylesheet" href="../main.css">
</head>
<body>
<script type="module">

	import * as THREE from '../../build/three.module.js';

	import { OrbitControls } from '../jsm/controls/OrbitControls.js';
	import { GLTFLoader } from '../jsm/loaders/GLTFLoader.js';
	import { GUI } from '../jsm/libs/dat.gui.module.js';
	import Stats from '../jsm/libs/stats.module.js';
	let camera, scene, renderer,modelSplit;


	// A regular tetrahedron for the clipping volume:

			let startTime, stats,

			object, clipMaterial,
			robotModel;

	function init() {

		camera = new THREE.PerspectiveCamera(
				36, window.innerWidth / window.innerHeight, 0.25, 16 );

		camera.position.set( 0, 5, 5 );

		scene = new THREE.Scene();
		scene.background = new THREE.CubeTextureLoader().load( //加载模型白天贴图
				[
					'./ambient/RT.jpg', //右
					'./ambient/LF.jpg', //左
					'./ambient/UP.jpg', // 上
					'./ambient/DN.jpg', // 下
					'./ambient/BK.jpg', // 前
					'./ambient/FR.jpg' // 后
				]);

		// Lights

		scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );
		// 聚光灯
		const spotLight = new THREE.SpotLight( 0xffffff, 0.5 );
		spotLight.angle = Math.PI / 5;
		spotLight.penumbra = 0.2;
		spotLight.position.set( 2, 3, 3 );
		spotLight.castShadow = true;
		spotLight.shadow.camera.near = 3;
		spotLight.shadow.camera.far = 10;
		spotLight.shadow.mapSize.width = 1024;
		spotLight.shadow.mapSize.height = 1024;
		scene.add( spotLight );
		// 直射灯光
		const dirLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
		dirLight.position.set( 0, 2, 0 );
		dirLight.castShadow = true;
		dirLight.shadow.camera.near = 1;
		dirLight.shadow.camera.far = 10;

		dirLight.shadow.camera.right = 1;
		dirLight.shadow.camera.left = - 1;
		dirLight.shadow.camera.top	= 1;
		dirLight.shadow.camera.bottom = - 1;

		dirLight.shadow.mapSize.width = 1024;
		dirLight.shadow.mapSize.height = 1024;
		scene.add( dirLight );

		// Geometry
		// 创建切割面
		let horizontalPlane=new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 1 );
		clipMaterial = new THREE.MeshPhongMaterial( {
			color: "#ee0a10",
			shininess: 100,
			side: THREE.DoubleSide,
			// Clipping setup:
			clippingPlanes: [horizontalPlane],
			clipShadows: true
		} );
		// 创建可见的切割面
		const horizontalGeometry = new THREE.PlaneGeometry( 3, 3, 1, 1 )
		const horizontalMesh = new THREE.Mesh( horizontalGeometry,
				new THREE.MeshBasicMaterial( {
					color: "#ff2520",
					side: THREE.DoubleSide,
					opacity: 0.5,
					transparent: true,
				} ) );
		horizontalMesh.rotation.x = - Math.PI / 2;
		horizontalMesh.position.y=1
		scene.add( horizontalMesh );
		//添加模型
		loadGLTFModel()

		//添加gltf模型
		function loadGLTFModel() {
			const loader = new GLTFLoader().setPath( '../models/gltf/RobotExpressive/' );
			let modelBox3 = new THREE.Box3();
			loader.load( 'RobotExpressive.glb', function ( gltf ) {
				let obj=gltf.scene;
				robotModel=obj;
				obj.traverse(node=>{
					if(node.type === "Mesh"){
						node.castShadow = true;
						node.material = new THREE.MeshStandardMaterial({
							color: node.material.color,
							clippingPlanes: clipMaterial.clippingPlanes,
							clipShadows: true,
							shadowSide: THREE.DoubleSide,
						});
						node.castShadow = true;
						node.renderOrder = 6;
					}
				})
				//重新设置中心点
				const boxmd = new THREE.Box3().setFromObject(obj);
				const center = boxmd.getCenter(new THREE.Vector3());
				obj.position.x += obj.position.x - center.x;
				obj.position.y += obj.position.y - center.y+3;
				obj.position.z += obj.position.z - center.z;
				obj.scale.set(0.2,0.2,0.2)
				modelBox3.expandByObject(obj);
				obj.updateMatrixWorld();
				scene.add( obj );
			} );
		}




		const planeGeometry = new THREE.PlaneGeometry( 3, 3, 1, 1 )

		const ground = new THREE.Mesh( planeGeometry,
				new THREE.MeshPhongMaterial( {
					color: 0xa0adaf, shininess: 10 } ) );
		ground.rotation.x = - Math.PI / 2;
		ground.scale.multiplyScalar( 3 );
		ground.receiveShadow = true;
		scene.add( ground );




		// Renderer
		const container = document.body;

		renderer = new THREE.WebGLRenderer();
		renderer.shadowMap.enabled = true;
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		window.addEventListener( 'resize', onWindowResize );
		container.appendChild( renderer.domElement );
		// Clipping setup:
		renderer.localClippingEnabled = true;

		// Stats
		stats = new Stats();
		container.appendChild( stats.dom );


		// Controls
		const controls = new OrbitControls( camera, renderer.domElement );
		controls.minDistance = 1;
		controls.maxDistance = 8;
		controls.target.set( 0, 1, 0 );
		controls.update();

		// 控制面板
		const gui = new GUI(),
				folderLocal = gui.addFolder( 'Local Clipping' ),
				propsLocal = {

					get 'Enabled'() {

						return renderer.localClippingEnabled;

					},
					set 'Enabled'( v ) {

						renderer.localClippingEnabled = v;

					},

					get 'Plane'() {

						return horizontalPlane.constant;

					},
					set 'Plane'( v ) {
						horizontalMesh.position.y=v
						horizontalPlane.constant = v;

					}

				};


		folderLocal.add( propsLocal, 'Enabled' );
		folderLocal.add( propsLocal, 'Plane', 0.3, 2 );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {

		requestAnimationFrame( animate );

		stats.begin();
		renderer.render( scene, camera );
		stats.end();

	}

	init();
	animate();



</script>

</body>
</html>
