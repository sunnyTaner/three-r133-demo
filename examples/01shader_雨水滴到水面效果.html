<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>着色器-雨滴水纹</title>
	<style>
		html, body{
			padding:  0;
			margin: 0;
			overflow: hidden;
		}
	</style>
</head>
<body>
<div id="demo"></div>

<script id="test4_fragment_shader" type="x-shader/x-fragment">
uniform float iTime;
uniform vec2 iResolution;
uniform sampler2D iChannel0;
vec2 iMouse = vec2(0.0, 0.0);

// Maximum number of cells a ripple can cross.
#define MAX_RADIUS 2

// Set to 1 to hash twice. Slower, but less patterns.
#define DOUBLE_HASH 0

// Hash functions shamefully stolen from:
// https://www.shadertoy.com/view/4djSRW
#define HASHSCALE1 .1031
#define HASHSCALE3 vec3(.1031, .1030, .0973)

float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

vec2 hash22(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);
    p3 += dot(p3, p3.yzx+19.19);
    return fract((p3.xx+p3.yz)*p3.zy);

}

void main()
{
    float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);
	vec2 uv = gl_FragCoord.xy / iResolution.y * resolution;
    vec2 p0 = floor(uv);

    vec2 circles = vec2(0.);
    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)
    {
        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)
        {
			vec2 pi = p0 + vec2(i, j);
            #if DOUBLE_HASH
            vec2 hsh = hash22(pi);
            #else
            vec2 hsh = pi;
            #endif
            vec2 p = pi + hash22(hsh);

            float t = fract(0.3*iTime + hash12(hsh));
            vec2 v = p - uv;
            float d = length(v) - (float(MAX_RADIUS) + 1.)*t;

            float h = 1e-3;
            float d1 = d - h;
            float d2 = d + h;
            float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);
            float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);
            circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));
        }
    }
    circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));

    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));
    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));
    vec3 color = texture2D(iChannel0, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);
	gl_FragColor = vec4(color, 1.0);
}
</script>
<script id="test4_vertexShader" type="x-shader/x-vertex">
	void main()
	{
		vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
		gl_Position = projectionMatrix * mvPosition;
	}
</script>

<script src="../build/three.js"></script>
<script type="text/javascript">
	var width = 0; // 画布的宽度
	var height = 0; // 画布的高度
	var scene = null; // 场景
	var camera = null; // 摄像机
	var renderer = null; // 渲染器
	var geom = null; // 几何体
	var uniforms = null; // 着色器使用参数
	var clock = new THREE.Clock(); // 时钟

	init();

	// 窗口大小改变后重新初始化
	window.addEventListener('resize', init);

	function init() {
		width = window.innerWidth; // 画布的宽度
		height = window.innerHeight; // 画布的高度

		/* 场景 */
		scene = createScene();

		/* 摄像机 */
		camera = createCamera();
		scene.add(camera); // 场景中添加相机

		/* 几何体 */
		geom = createGeom();
		scene.add(geom); // 场景中添加几何体

		/* 渲染器 */
		renderer = createRenderer();

		render();
	}

	/* 创建场景 */
	function createScene () {
		var scene = new THREE.Scene();
		// 坐标轴
		var axesHelper=new THREE.AxesHelper(10);
		scene.add(axesHelper);

		/*// 网格
		var gridHelper=new THREE.GridHelper(100, 20, 0xffff00, 0x808080);
		gridHelper.position.set(-2, 0, -2);
		scene.add(gridHelper);*/
		return scene;
	}
	/* 创建摄像机 */
	function createCamera () {
		var camera = new THREE.PerspectiveCamera(45, width/height, 1, 2000);
		camera.position.set(0,0,360);
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		return camera
	}

	/* 创建渲染器 */
	function createRenderer () {
		var renderer = new THREE.WebGLRenderer({antialias:true});
		renderer.setSize(width, height);
		var parentElement = document.getElementById('demo');
		parentElement.innerHTML = '';
		parentElement.appendChild(renderer.domElement);
		return renderer;
	}

	/* 创建几何体 */
	function createGeom () {
		var texture = new THREE.TextureLoader().load( "./textures/shader/img1.jpg");
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;

		uniforms = {
			iTime: { value: 1.0 },
			iResolution: { value: new THREE.Vector2(width * 1.0, height * 1.0)},
			iChannel0: {value: texture}
		}

		var material = new THREE.ShaderMaterial( {
			uniforms: uniforms,
			vertexShader: document.getElementById( 'test4_vertexShader' ).textContent,
			fragmentShader: document.getElementById('test4_fragment_shader').textContent
		});

		var geom = new THREE.PlaneBufferGeometry(width, height);
		var mesh = new THREE.Mesh( geom, material );
		return mesh;
	}

	/* 渲染 */
	function render() {
		// 获得距离上次调用的时间间隔
		var delta = clock.getDelta();
		uniforms.iTime.value += delta;
		renderer.render(scene, camera);
		requestAnimationFrame(render);
	}
</script>
</body>
